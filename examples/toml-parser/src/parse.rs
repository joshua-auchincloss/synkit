//! Parse implementations for TOML AST nodes
//!
//! Parse implementations for token types are auto-generated by the `parser_kit!` macro.
//! This module contains Parse implementations for AST nodes only.

use crate::ast::*;
use crate::stream::TokenStream;
use crate::tokens::Token;
use crate::{Parse, Peek, Spanned, TomlError, tokens};
use synkit::TokenStream as _;

// ANCHOR: peek_impl
// Helper function to peek at raw tokens (including newlines)
fn peek_raw(stream: &TokenStream) -> Option<&Token> {
    stream.peek_token_raw().map(|t| &t.value)
}

/// Check if the next raw token is a newline
fn peek_newline(stream: &TokenStream) -> bool {
    matches!(peek_raw(stream), Some(Token::Newline))
}
// ANCHOR_END: peek_impl

// ANCHOR: parse_trivia
impl Peek for Trivia {
    fn is(token: &Token) -> bool {
        matches!(token, Token::Newline | Token::Comment)
    }

    fn peek(stream: &TokenStream) -> bool {
        peek_raw(stream).map(Self::is).unwrap_or(false)
    }
}

impl Parse for Trivia {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        match peek_raw(stream) {
            Some(Token::Newline) => Ok(Trivia::Newline(stream.parse()?)),
            Some(Token::Comment) => Ok(Trivia::Comment(stream.parse()?)),
            Some(other) => Err(TomlError::Expected {
                expect: "newline or comment",
                found: format!("{}", other),
            }),
            None => Err(TomlError::Empty {
                expect: "newline or comment",
            }),
        }
    }
}
// ANCHOR_END: parse_trivia

// ANCHOR: parse_simple_key
impl Peek for SimpleKey {
    fn is(token: &Token) -> bool {
        matches!(token, Token::BareKey(_) | Token::BasicString(_))
    }
}

impl Parse for SimpleKey {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        match stream.peek_token().map(|t| &t.value) {
            Some(Token::BareKey(_)) => {
                let tok: Spanned<tokens::BareKeyToken> = stream.parse()?;
                Ok(SimpleKey::Bare(tok.value))
            }
            Some(Token::BasicString(_)) => {
                let tok: Spanned<tokens::BasicStringToken> = stream.parse()?;
                Ok(SimpleKey::Quoted(tok.value))
            }
            Some(other) => Err(TomlError::Expected {
                expect: "key",
                found: format!("{}", other),
            }),
            None => Err(TomlError::Empty { expect: "key" }),
        }
    }
}
// ANCHOR_END: parse_simple_key

// ANCHOR: parse_key
impl Peek for Key {
    fn is(token: &Token) -> bool {
        SimpleKey::is(token)
    }
}

impl Parse for Key {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        let first: Spanned<SimpleKey> = stream.parse()?;

        // Check if this is a dotted key
        if stream.peek::<tokens::DotToken>() {
            let mut rest = Vec::new();
            while stream.peek::<tokens::DotToken>() {
                let dot: Spanned<tokens::DotToken> = stream.parse()?;
                let key: Spanned<SimpleKey> = stream.parse()?;
                rest.push((dot, key));
            }
            Ok(Key::Dotted(DottedKey { first, rest }))
        } else {
            // Single key
            match first.value {
                SimpleKey::Bare(tok) => Ok(Key::Bare(tok)),
                SimpleKey::Quoted(tok) => Ok(Key::Quoted(tok)),
            }
        }
    }
}
// ANCHOR_END: parse_key

// ANCHOR: parse_value
impl Peek for Value {
    fn is(token: &Token) -> bool {
        matches!(
            token,
            Token::BasicString(_)
                | Token::Integer(_)
                | Token::True
                | Token::False
                | Token::LBracket
                | Token::LBrace
        )
    }
}

impl Parse for Value {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        match stream.peek_token().map(|t| &t.value) {
            Some(Token::BasicString(_)) => {
                let tok: Spanned<tokens::BasicStringToken> = stream.parse()?;
                Ok(Value::String(tok.value))
            }
            Some(Token::Integer(_)) => {
                let tok: Spanned<tokens::IntegerToken> = stream.parse()?;
                Ok(Value::Integer(tok.value))
            }
            Some(Token::True) => {
                let tok: Spanned<tokens::TrueToken> = stream.parse()?;
                Ok(Value::True(tok.value))
            }
            Some(Token::False) => {
                let tok: Spanned<tokens::FalseToken> = stream.parse()?;
                Ok(Value::False(tok.value))
            }
            Some(Token::LBracket) => {
                let arr = Array::parse(stream)?;
                Ok(Value::Array(arr))
            }
            Some(Token::LBrace) => {
                let tbl = InlineTable::parse(stream)?;
                Ok(Value::InlineTable(tbl))
            }
            Some(other) => Err(TomlError::Expected {
                expect: "value",
                found: format!("{}", other),
            }),
            None => Err(TomlError::Empty { expect: "value" }),
        }
    }
}
// ANCHOR_END: parse_value

// ANCHOR: parse_array
impl Peek for Array {
    fn is(token: &Token) -> bool {
        matches!(token, Token::LBracket)
    }
}

impl Parse for Array {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        let lbracket: Spanned<tokens::LBracketToken> = stream.parse()?;

        let mut items = Vec::new();

        // Skip any leading newlines inside array
        while peek_newline(stream) {
            let _: Spanned<tokens::NewlineToken> = stream.parse()?;
        }

        // Parse array items
        while stream.peek::<Value>() {
            let value: Spanned<Value> = stream.parse()?;

            // Skip newlines after value
            while peek_newline(stream) {
                let _: Spanned<tokens::NewlineToken> = stream.parse()?;
            }

            let comma = if stream.peek::<tokens::CommaToken>() {
                let c: Spanned<tokens::CommaToken> = stream.parse()?;
                // Skip newlines after comma
                while peek_newline(stream) {
                    let _: Spanned<tokens::NewlineToken> = stream.parse()?;
                }
                Some(c)
            } else {
                None
            };

            items.push(ArrayItem { value, comma });
        }

        let rbracket: Spanned<tokens::RBracketToken> = stream.parse()?;

        Ok(Array {
            lbracket,
            items,
            rbracket,
        })
    }
}
// ANCHOR_END: parse_array

// ANCHOR: parse_inline_table
impl Peek for InlineTable {
    fn is(token: &Token) -> bool {
        matches!(token, Token::LBrace)
    }
}

impl Parse for InlineTable {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        let lbrace: Spanned<tokens::LBraceToken> = stream.parse()?;

        let mut items = Vec::new();

        // Parse inline table items
        while stream.peek::<Key>() {
            let kv: Spanned<KeyValue> = stream.parse()?;

            let comma = if stream.peek::<tokens::CommaToken>() {
                Some(stream.parse()?)
            } else {
                None
            };

            items.push(InlineTableItem { kv, comma });
        }

        let rbrace: Spanned<tokens::RBraceToken> = stream.parse()?;

        Ok(InlineTable {
            lbrace,
            items,
            rbrace,
        })
    }
}
// ANCHOR_END: parse_inline_table

// ANCHOR: parse_key_value
impl Peek for KeyValue {
    fn is(token: &Token) -> bool {
        Key::is(token)
    }
}

impl Parse for KeyValue {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        let key: Spanned<Key> = stream.parse()?;
        let eq: Spanned<tokens::EqToken> = stream.parse()?;
        let value: Spanned<Value> = stream.parse()?;

        Ok(KeyValue { key, eq, value })
    }
}
// ANCHOR_END: parse_key_value

// ANCHOR: parse_table
impl Peek for Table {
    fn is(token: &Token) -> bool {
        matches!(token, Token::LBracket)
    }
}

impl Parse for Table {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        let lbracket: Spanned<tokens::LBracketToken> = stream.parse()?;
        let name: Spanned<Key> = stream.parse()?;
        let rbracket: Spanned<tokens::RBracketToken> = stream.parse()?;

        let mut items = Vec::new();

        // Consume trailing content on the header line
        while Trivia::peek(stream) {
            let trivia = Trivia::parse(stream)?;
            items.push(TableItem::Trivia(trivia));
            // Stop after we hit a newline
            if matches!(items.last(), Some(TableItem::Trivia(Trivia::Newline(_)))) {
                break;
            }
        }

        // Parse table contents until we hit another table or EOF
        loop {
            // Check for trivia (newlines, comments)
            if Trivia::peek(stream) {
                let trivia = Trivia::parse(stream)?;
                items.push(TableItem::Trivia(trivia));
                continue;
            }

            // Check for key-value pair
            if stream.peek::<Key>() {
                // But first make sure this isn't a table header by checking for `[`
                // This is tricky - we need to distinguish `[table]` from key-value
                // Since Key::peek checks for bare keys and strings, and table headers
                // start with `[`, we need to check `[` first in the document parser
                let kv: Spanned<KeyValue> = stream.parse()?;
                items.push(TableItem::KeyValue(kv));
                continue;
            }

            // Either EOF or another table section
            break;
        }

        Ok(Table {
            lbracket,
            name,
            rbracket,
            items,
        })
    }
}
// ANCHOR_END: parse_table

// ANCHOR: parse_document
impl Peek for DocumentItem {
    fn is(token: &Token) -> bool {
        Trivia::is(token) || Key::is(token) || matches!(token, Token::LBracket)
    }
}

impl Parse for Document {
    fn parse(stream: &mut TokenStream) -> Result<Self, TomlError> {
        let mut items = Vec::new();

        loop {
            // Check for trivia (newlines, comments)
            if Trivia::peek(stream) {
                let trivia = Trivia::parse(stream)?;
                items.push(DocumentItem::Trivia(trivia));
                continue;
            }

            // Check for table header `[name]`
            if stream.peek::<tokens::LBracketToken>() {
                let table: Spanned<Table> = stream.parse()?;
                items.push(DocumentItem::Table(table));
                continue;
            }

            // Check for key-value pair
            if stream.peek::<Key>() {
                let kv: Spanned<KeyValue> = stream.parse()?;
                items.push(DocumentItem::KeyValue(kv));
                continue;
            }

            // EOF or unknown token
            if stream.is_empty() {
                break;
            }

            // Unknown token - error
            if let Some(tok) = stream.peek_token() {
                return Err(TomlError::Expected {
                    expect: "key, table, or end of file",
                    found: format!("{}", tok.value),
                });
            }
            break;
        }

        Ok(Document { items })
    }
}
// ANCHOR_END: parse_document

#[cfg(test)]
mod tests {
    use crate::Spanned;
    use crate::ast::*;
    use crate::stream::TokenStream;
    use crate::tokens::SpannedTok;

    #[test]
    fn test_parse_bare_key() {
        let mut stream = TokenStream::lex("foo").unwrap();
        let key: Spanned<SimpleKey> = stream.parse().unwrap();
        assert!(matches!(key.value, SimpleKey::Bare(_)));
    }

    #[test]
    fn test_parse_quoted_key() {
        let mut stream = TokenStream::lex(r#""foo.bar""#).unwrap();
        let key: Spanned<SimpleKey> = stream.parse().unwrap();
        assert!(matches!(key.value, SimpleKey::Quoted(_)));
    }

    #[test]
    fn test_parse_dotted_key() {
        let mut stream = TokenStream::lex("foo.bar.baz").unwrap();
        let key: Spanned<Key> = stream.parse().unwrap();
        assert!(matches!(key.value, Key::Dotted(_)));
    }

    #[test]
    fn test_parse_string_value() {
        let mut stream = TokenStream::lex(r#""hello""#).unwrap();
        let value: Spanned<Value> = stream.parse().unwrap();
        assert!(matches!(value.value, Value::String(_)));
    }

    #[test]
    fn test_parse_integer_value() {
        let mut stream = TokenStream::lex("42").unwrap();
        let value: Spanned<Value> = stream.parse().unwrap();
        assert!(matches!(value.value, Value::Integer(_)));
    }

    #[test]
    fn test_parse_boolean_value() {
        let mut stream = TokenStream::lex("true").unwrap();
        let value: Spanned<Value> = stream.parse().unwrap();
        assert!(matches!(value.value, Value::True(_)));
    }

    #[test]
    fn test_token_macro() {
        // Test that SpannedTok! macro works from within the crate
        // Import from the tokens module: `use crate::tokens::SpannedTok;`
        let mut stream = TokenStream::lex("=").unwrap();
        // SpannedTok![=] resolves to Spanned<EqToken>
        let _eq: SpannedTok![=] = stream.parse().unwrap();
    }
}
