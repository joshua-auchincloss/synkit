//! ToTokens implementations for round-trip formatting
//!
//! Most token ToTokens implementations are auto-generated by `parser_kit!`.
//! Custom implementations are only needed for tokens with special formatting needs.

use crate::ast::*;
use crate::{Printer, ToTokens, tokens};
use synkit::Printer as PrinterTrait;

// ANCHOR: print_tokens
// Custom ToTokens implementations for tokens that need special handling.
// Other token ToTokens are auto-generated by parser_kit!

impl ToTokens for tokens::BasicStringToken {
    fn write(&self, p: &mut Printer) {
        // BasicString stores content without quotes, so we add them back for round-trip
        p.word("\"");
        p.word(&self.0);
        p.word("\"");
    }
}

impl ToTokens for tokens::NewlineToken {
    fn write(&self, p: &mut Printer) {
        p.newline();
    }
}
// ANCHOR_END: print_tokens

// ANCHOR: print_trivia
impl ToTokens for Trivia {
    fn write(&self, p: &mut Printer) {
        match self {
            Trivia::Newline(nl) => nl.value.write(p),
            Trivia::Comment(c) => c.value.write(p),
        }
    }
}
// ANCHOR_END: print_trivia

// ANCHOR: print_simple_key
impl ToTokens for SimpleKey {
    fn write(&self, p: &mut Printer) {
        match self {
            SimpleKey::Bare(tok) => tok.write(p),
            SimpleKey::Quoted(tok) => tok.write(p),
        }
    }
}
// ANCHOR_END: print_simple_key

// ANCHOR: print_key
impl ToTokens for DottedKey {
    fn write(&self, p: &mut Printer) {
        self.first.value.write(p);
        for (dot, key) in &self.rest {
            dot.value.write(p);
            key.value.write(p);
        }
    }
}

impl ToTokens for Key {
    fn write(&self, p: &mut Printer) {
        match self {
            Key::Bare(tok) => tok.write(p),
            Key::Quoted(tok) => tok.write(p),
            Key::Dotted(dotted) => dotted.write(p),
        }
    }
}
// ANCHOR_END: print_key

// ANCHOR: print_value
impl ToTokens for Value {
    fn write(&self, p: &mut Printer) {
        match self {
            Value::String(tok) => tok.write(p),
            Value::Integer(tok) => tok.write(p),
            Value::True(tok) => tok.write(p),
            Value::False(tok) => tok.write(p),
            Value::Array(arr) => arr.write(p),
            Value::InlineTable(tbl) => tbl.write(p),
        }
    }
}
// ANCHOR_END: print_value

// ANCHOR: print_array
impl ToTokens for ArrayItem {
    fn write(&self, p: &mut Printer) {
        self.value.value.write(p);
        if let Some(comma) = &self.comma {
            comma.value.write(p);
            p.space();
        }
    }
}

impl ToTokens for Array {
    fn write(&self, p: &mut Printer) {
        self.lbracket.value.write(p);
        for item in &self.items {
            item.write(p);
        }
        self.rbracket.value.write(p);
    }
}
// ANCHOR_END: print_array

// ANCHOR: print_inline_table
impl ToTokens for InlineTableItem {
    fn write(&self, p: &mut Printer) {
        self.kv.value.write(p);
        if let Some(comma) = &self.comma {
            comma.value.write(p);
            p.space();
        }
    }
}

impl ToTokens for InlineTable {
    fn write(&self, p: &mut Printer) {
        self.lbrace.value.write(p);
        p.space();
        for item in &self.items {
            item.write(p);
        }
        self.rbrace.value.write(p);
    }
}
// ANCHOR_END: print_inline_table

// ANCHOR: print_key_value
impl ToTokens for KeyValue {
    fn write(&self, p: &mut Printer) {
        self.key.value.write(p);
        p.space();
        self.eq.value.write(p);
        p.space();
        self.value.value.write(p);
    }
}
// ANCHOR_END: print_key_value

// ANCHOR: print_table
impl ToTokens for TableItem {
    fn write(&self, p: &mut Printer) {
        match self {
            TableItem::Trivia(trivia) => trivia.write(p),
            TableItem::KeyValue(kv) => kv.value.write(p),
        }
    }
}

impl ToTokens for Table {
    fn write(&self, p: &mut Printer) {
        self.lbracket.value.write(p);
        self.name.value.write(p);
        self.rbracket.value.write(p);
        for item in &self.items {
            item.write(p);
        }
    }
}
// ANCHOR_END: print_table

// ANCHOR: print_document
impl ToTokens for DocumentItem {
    fn write(&self, p: &mut Printer) {
        match self {
            DocumentItem::Trivia(trivia) => trivia.write(p),
            DocumentItem::KeyValue(kv) => kv.value.write(p),
            DocumentItem::Table(table) => table.value.write(p),
        }
    }
}

impl ToTokens for Document {
    fn write(&self, p: &mut Printer) {
        for item in &self.items {
            item.write(p);
        }
    }
}
// ANCHOR_END: print_document
